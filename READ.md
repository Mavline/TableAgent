# SOP: Разработка прикладного ChatGPT-подобного приложения для работы с таблицами

## Цель
Цель этого документа - предоставить стандартизированные операционные инструкции (SOP) для создания ChatGPT-подобного приложения с возможностью обработки табличных данных, таких как файлы Excel (.xlsx), через интерактивный диалог. Приложение должно позволять пользователям загружать файлы, обрабатывать данные с помощью агента, а также возвращать обработанные данные и математические вычисления в удобной форме.

## Основные Компоненты
1. **Диалоговое окно пользователя**: интерфейс взаимодействия, напоминающий ChatGPT.
2. **Загрузка файлов**: возможность загрузки таблиц в форматах .xlsx, CSV, и JSON.
3. **Обработка данных**: подготовка среды для обработки и разбора данных с помощью Python библиотек и агента.
4. **Вывод информации**: представление результатов в виде текста, таблиц и формул, а также генерация файлов для скачивания.
5. **API интеграция**: использование API, таких как Replicate или Nvidia, для обработки данных.

## Инструменты и Среда
- **Frontend**: Используйте библиотеку **Tkinter** для создания диалогового окна и интерфейса загрузки файлов.
- **Backend**:
  - **Openpyxl** и **Pandas** для работы с Excel файлами (.xlsx).
  - **CSV** модуль Python и Pandas для работы с CSV файлами.
  - **json** модуль Python для работы с JSON файлами.
  - **MathJax** или аналогичные библиотеки для отображения математических формул в окне чата.
- **API**: Используйте **Replicate API** или **Nvidia API** для расширенной обработки данных.

## Конкретный API для Использования
### Node.js Реализация
- Установите пакет API:
  ```sh
  npm install replicate
  ```
- Используйте следующий код для интеграции API в ваше приложение:
  ```javascript
  import Replicate from "replicate";
  const replicate = new Replicate();

  const input = {
      prompt: "How many r in strawberry?"
  };

  for await (const event of replicate.stream("lucataco/ollama-nemotron-70b:730a266b3a0db453479d5b167132fd6534debde168af62ac328d5d0187d18e0e", { input })) {
    process.stdout.write(`${event}`);
    //=> "A"
  }
  process.stdout.write("\n");
  ```

### Python Реализация
- Установите библиотеку Replicate:
  ```sh
  pip install replicate
  ```
- Используйте следующий код для интеграции API в ваше приложение:
  ```python
  import replicate

  input = {
      "prompt": "How many r in strawberry?"
  }

  for event in replicate.stream(
      "lucataco/ollama-nemotron-70b:730a266b3a0db453479d5b167132fd6534debde168af62ac328d5d0187d18e0e",
      input=input
  ):
      print(event, end="")
      #=> "A"
  ```

## Шаги для Реализации

### 1. Разработка Интерфейса Пользователя
1. **Создание интерфейса загрузки файлов** с помощью Tkinter:
   - Предусмотреть кнопку для загрузки файла с возможностью выбора форматов .xlsx, CSV или JSON.
   - Обеспечить базовую проверку загружаемого файла на соответствие требованиям формата.
2. **Диалоговое окно**: добавьте окно чата, где пользователь может взаимодействовать с агентом, вводя запросы на анализ данных.

### Конкретные Рекомендации по Реализации Интерфейса и Подключения Модели
1. **Разработка UI**: используйте Tkinter для создания простого интерфейса. Окно должно включать область для чата и кнопку загрузки файлов. После загрузки, файлы должны быть переданы в бэкэнд для обработки.
2. **Подключение Модели**: модель, связанная через Replicate API, должна быть интегрирована таким образом, чтобы она могла обрабатывать запросы от пользователя в реальном времени. Например, после загрузки файла и ввода запроса, модель должна использовать загруженные данные для ответа на вопросы пользователя.
3. **Готовая Среда для Модели**:
   - Используйте подготовленные данные и библиотеки, такие как Pandas или Openpyxl, для предварительной обработки данных, чтобы модель имела доступ к уже готовой информации.
   - Создайте структуру, в которой модель может запросить у клиента необходимые части данных, а также использовать сгенерированные данные для выполнения вычислений и дальнейшей обработки.

### 2. Подготовка Среды для Обработки Таблиц
1. **Openpyxl/Pandas**: интеграция библиотек для загрузки и разбора Excel файлов.
2. **Pandas** для чтения и обработки CSV и JSON файлов.
3. **Создание функции анализа данных**: создайте функции для выполнения базового анализа данных, таких как фильтрация, группировка и создание сводок.

### 3. Интеграция ЛЛМ Агента
1. **Обучение Агента**:

   Подумайте о возможности использования визуальных моделей, таких как OCR (например, Tesseract), для считывания данных из таблиц и их последующей обработки. Это может быть хорошим вариантом для более сложных табличных структур, особенно если данные содержат визуальные элементы или нестандартные форматы. используйте API для того, чтобы агент мог обрабатывать табличные данные и формировать ответы.
2. **Обработка Запросов**: агент должен иметь возможность разбирать запросы, касающиеся анализа данных, и использовать подготовленные функции Pandas/Openpyxl для выполнения операций.
3. **Иллюстрация Результатов**:
   - Используйте MathJax для отображения математических формул в диалоговом окне.
   - Формируйте таблицы для визуализации результатов анализа (например, head() из DataFrame).

### 4. Генерация и Скачивание Файлов
1. **Создание Выходных Файлов**: на основе анализа данных формируйте выходные файлы (в формате Excel, CSV или JSON), используя Openpyxl или Pandas.
2. **Кнопка Скачивания**: добавьте кнопку для скачивания обработанных данных.

### 5. Интеграция API Replicate/Nvidia
1. **Авторизация и Настройка**: настройте доступ к API с использованием ключей авторизации.
2. **Отправка Запросов**: создайте обработчики для отправки данных в API и получения результатов.
3. **Использование Результатов**: результаты обработки данных должны быть представлены в виде ответа агента или файла, доступного для скачивания.

### 6. Тестирование и Доработка
1. **Тестирование функционала**: проверьте загрузку файлов, обработку данных, взаимодействие с агентом и скачивание выходных файлов.
2. **Исправление ошибок**: при необходимости исправьте ошибки, связанные с загрузкой, разбором или отображением данных.
3. **Оптимизация UX**: убедитесь, что интерфейс интуитивно понятен, и агент даёт полезные и структурированные ответы.

## Логирование и Обработка Ошибок

### Логирование
1. **Критические события**:
   - Ошибки при загрузке файлов
   - Сбои в работе API
   - Ошибки обработки данных

2. **Структура логов**:
   ```python
   import logging
   
   logging.basicConfig(
       filename='app.log',
       format='%(asctime)s - %(levelname)s - %(message)s',
       level=logging.INFO
   )
   ```

### Обработка Ошибок
1. **Загрузка файлов**:
   - Проверка формата (.xlsx)
   - Информативные сообщения пользователю при ошибках
   
2. **API взаимодействие**:
   - Обработка недоступности API
   - Информирование пользователя о статусе операций

### Конфигурация API
- Хранение конфигурации в отдельном файле `.env`:
  ```
  API_KEY=your_api_key
  API_URL=https://api.example.com
  ```

## Обработка Ошибок и Безопасность

### Обработка Ошибок
1. **Загрузка файлов**:
   - Проверка целостности файла
   - Валидация формата и структуры
   - Обработка превышения размера файла

2. **API взаимодействие**:
   - Обработка превышения лимитов API
   - Повторные попытки при временных сбоях
   - Логирование ошибок

### Безопасность
1. **Хранение учетных данных**:
   - Использование переменных окружения для API ключей
   - Шифрование локально хранимых данных

2. **Валидация файлов**:
   - Проверка на вредоносный код
   - Ограничение размера файлов
   - Белый список разрешенных форматов

## Пример Реализации Интерфейса (Tkinter)
```python
import tkinter as tk
from tkinter import filedialog
import pandas as pd

def load_file():
    file_path = filedialog.askopenfilename()
    if file_path.endswith(('.xlsx', '.csv', '.json')):
        if file_path.endswith('.xlsx'):
            df = pd.read_excel(file_path)
        elif file_path.endswith('.csv'):
            df = pd.read_csv(file_path)
        else:
            with open(file_path, 'r') as f:
                df = pd.read_json(f)
        # Here you can add processing or send df to the agent for analysis
        print(df.head())
    else:
        print("Unsupported file format.")

root = tk.Tk()
root.title("ChatGPT-like Table Processing App")

load_button = tk.Button(root, text="Load File", command=load_file)
load_button.pack()

root.mainloop()
```

## Заключение
Следуя этим шагам, вы сможете создать приложение, которое будет служить мощным инструментом для интерактивной обработки табличных данных. Основной фокус делается на функциональность и удобство для пользователя, чтобы агент мог эффективно обрабатывать данные и предоставлять полезные ответы и файлы для скачивания.

## Работа с ИИ Моделями

### Переключение Провайдеров
1. **Абстракция Провайдера**:
   ```python
   class ModelProvider:
       def __init__(self, config):
           self.config = config
           
       async def process_table(self, data, prompt):
           raise NotImplementedError
   ```

2. **Реализации для Разных Провайдеров**:
   - OpenRouter
   - Replicate
   - Nvidia
   - OpenAI
   
   Это позволит легко экспериментировать с разными моделями через единый интерфейс.

### Использование Визуальных Моделей
1. **Преимущества**:
   - Возможность работы с нестандартными форматами таблиц
   - Обработка сканированных документов
   - Понимание визуальной структуры данных

2. **Недостатки**:
   - Дополнительная сложность интеграции
   - Возможные ошибки при распознавании
   - Увеличение времени обработки

**Рекомендация**: На первом этапе лучше сосредоточиться на работе с прямым доступом к данным через pandas/openpyxl. Визуальную модель можно добавить позже, если появится необходимость работы со сканированными документами.

### Мультимодельный Подход
1. **Возможные комбинации**:
   - Основная LLM для анализа и ответов
   - Специализированная модель для кода
   - Визуальная модель для OCR

2. **Сложности**:
   - Усложнение архитектуры
   - Увеличение стоимости запросов
   - Необходимость координации между моделями

**Рекомендация**: Начать с одной универсальной LLM модели (например, GPT-4 или Claude), которая хорошо справляется как с анализом данных, так и с генерацией кода. Добавлять специализированные модели только при явной необходимости в их специфических возможностях.

